
#include "AbsorptionMap.h"
ClassImp(AbsorptionMap);

//______________________________________________________________________________
/* Begin_Html
 <center><h2>AbsorptionMap class</h2></center>
 An <i>AbsorptionMap</i> is an object which reads ROOT files containing sparse histograms with radiation mesh tallies
 and generates a radiation map. Such ROOT files can be generated by first performing Monte Carlo simulations to
 obtain radiation mesh grids and secondly, using mctal2root to convert the Monte Carlo simulations to .root
 format.
 <p>
 By setting a response function to the object, <i>AbsorptionMap</i> folds the radiation map with the response function and generates a map revealing the absorbed dose of the object which the response function represents.
 <p>

 
 <h4>Draw radiation maps</h4>
 <p>
 Drawing a radiation maps requires a TCanvas. Drawing the maps can hence be performed as follows:
 <pre>
 AbsorptionMap *a1 = new AbsorptionMap("a1 title", TString vector of filenames);
 TCanvas *c1 = new TCanvas();
 a1->Draw();
 </pre>
 
 <h4>Introduce reponse function</h4>
 <p>
 Introducing a response function to an AbsorptionMap object, enables the computation and drawing of a map
 revealing the absorbed dose. Setting a response function is performed as follows:
 <pre>
 AbsorptionMap *a1 = new AbsorptionMap("a1 title", TString vector of filenames);
 a1->SetResponseFunction("file name");
 </pre>
 
 
 
 <h4>Draw a map revealing the absorbed radiation</h4>
 <p>
 Drawing a absorption maps requires a TCanvas as well as a response function (see Introduce reponse function).
 Drawing the maps is hence performed as follows:
 <pre>
 AbsorptionMap *a1 = new AbsorptionMap("a1 title", TString vector of filenames);
 a1->SetResponseFunction("file name");
 TCanvas *c1 = new TCanvas();
 a1->Draw();
 </pre>
 
 
 
 
 </p>
 <center><h2> Acknowledgements</h2></center>
 </p>
 <center>Recognition goes to Nicolo Borghi and Konstantin Batkov for the development of mctal2root, without which this class could not have been created. Special thanks goes to Riccardo Bevilacqua for his ideas to this class, and to Konstantin Batkov for invaluable help with programming.</center>
 
 
 </p>
 <center><h2>mctal2root</h2></center>
 </p>
 With the mctal2root converter, ASCII MCTAL files produced by MCNPX are converted into binary ROOT files containing a set of [<a href="http://root.cern.ch/root/html/THnSparse.html">THnSparseF</a>], one for each tally. More about mctal2root can be found at <a href="https://code.google.com/p/mc-tools/">here</a>.
 
 
 End_Html
 */




Bool_t AbsorptionMap::fAutoUpdate = false;
AbsorptionMap::AbsorptionMap(const char *name, vector<TString> fileNames){
    //    Constructor
    fIsAbsMap = false;
    fName = name;
    fFileNames = fileNames;
    fNumberOfFiles = fFileNames.size();
    GetMeshGrids();
    CreateMesh("Radiation");
    GenerateRadMap();
}

AbsorptionMap::~AbsorptionMap(){
    //    Destructor
    
    delete fRadMap; fRadMap = 0;
}

void AbsorptionMap::GetMeshGrids(){
    //    Extract mesh grids from imported files. Acceptable mesh grids have 11 dimensions and will be added to the
    //    private class member vector fRmesh.
    fMeshCount = 0;
    const char *histName;
    for (Int_t i=0; i<fNumberOfFiles; i++) {
        TFile *file = new TFile(fFileNames[i].Data());
        TIter next(file->GetListOfKeys());
        TKey *key;
        while ((key = (TKey*)next())) {
            histName = key->GetName();
            THnSparseF *tmpsparse = (THnSparseF*)file->Get(histName);
            Int_t dimensions = tmpsparse->GetNdimensions();
            if (dimensions == 11) {
                fRmesh.push_back(tmpsparse);
                fMeshCount++;
            } else if (dimensions != 8) {
                std::cerr << "A mesh grid with " << dimensions << " dimensions was found. This aught to be incorrect, please check mesh grid dimensions" << std::endl;
                return;
            }
        }
        file->Close();
        delete file;
    }
}


void AbsorptionMap::CreateMesh(TString mapName){
    //    Create a sparse histogram for radiation map with correct attributes.
    const int nDim = 4;
    TAxis *Xaxis = fRmesh[0]->GetAxis(8);
    TAxis *Yaxis = fRmesh[0]->GetAxis(9);
    TAxis *Zaxis = fRmesh[0]->GetAxis(10);
    fX = Xaxis->GetNbins();
    fY = Yaxis->GetNbins();
    fZ = Zaxis->GetNbins();
    Double_t Xmin = Xaxis->GetXmin();
    Double_t Ymin = Yaxis->GetXmin();
    Double_t Zmin = Zaxis->GetXmin();
    Double_t Xmax = Xaxis->GetXmax();
    Double_t Ymax = Yaxis->GetXmax();
    Double_t Zmax = Zaxis->GetXmax();
    Int_t nBins[nDim] = {fX,fY,fZ,fMeshCount};
    Double_t min[nDim] = {Xmin, Ymin, Zmin, 0};
    Double_t max[nDim] = {Xmax, Ymax, Zmax, 1};
    TObject *obj = gROOT->FindObject(mapName);
    if (obj) {
        delete obj; obj = 0;
    }
    if (strcmp(mapName, "Radiation") == 0) {
        string rad(" Radiation");
        rad = fName + rad;
        fRadName = rad.c_str();
        fRadMap = new THnSparseF(fRadName, "Radiation map", nDim, nBins, min, max);
    }else if (strcmp(mapName, "Absorption") == 0){
        string abs(" Absorption");
        abs = fName + abs;
        fAbsName = abs.c_str();
        fAbsMap = new THnSparseF(fAbsName, "Absorption map", nDim, nBins, min, max);
    }
}

void AbsorptionMap::GenerateRadMap(){
    //    Extract information from all mesh grids in fRmesh to generate the radiation map fRadMap.
    fRadMax = -100;
    fRadMin = 100;
    Double_t content, error;
    Long64_t linIndex;
    for (Int_t i=1; i<=fX; i++) {
        for (Int_t j=1; j<=fY; j++) {
            for (Int_t k=1; k<=fZ; k++) {
                Int_t coord[11] = {1,1,1,1,1,1,1,1,i,j,k};
                for (Int_t l=0; l<fMeshCount; l++) {
                    linIndex = fRmesh[l]->GetBin(coord);
                    content = fRmesh[l]->GetBinContent(linIndex);
                    error = fRmesh[l]->GetBinError(linIndex);
                    Int_t compCoord[4] = {i,j,k,l+1};
                    Long64_t compLinIndex = fRadMap->GetBin(compCoord);
                    fRadMap->SetBinContent(compLinIndex, content);
                    fRadMap->SetBinError(compLinIndex, error);
                    if (log10(content) > fRadMax) {
                        fRadMax = log10(content);
                    }
                    if (log10(content) < fRadMin && content != 0) {
                        fRadMin = log10(content);
                    }
                }
            }
        }
    }
    fRadMapProjection = fRadMap->Projection(0,1);
    //TFile file("test.root","RECREATE");
    //fRadMap->Write();
}

void AbsorptionMap::SetResponseFunction(const char *fRFName){
    //    Set response function for a given device or material. A map revealing the radiation absorption of the
    //    device, in the room for which the radiation map has been produced, will be generated.
    TFile *f = new TFile(fRFName);
    TIter next(f->GetListOfKeys());
    TKey *key=(TKey*)next();
    const char *histName = key->GetName();
    fRF = (TH1F*)f->Get(histName);
    fRFBins = fRF->GetNbinsX();
    fRF->SetDirectory(0);
    f->Close();
    delete f;
    CreateMesh("Absorption");
    GenerateAbsMap();
}

Double_t AbsorptionMap::GetAbsContent(Int_t i, Double_t content){
    //    Fold radiation with response function at a given location in the room for which the radiation map has been
    //    produced.
    fAbsMap->Sumw2();
    Double_t fRFContent = fRF->GetBinContent(i);
    Double_t absContent = fRFContent*content;
    return absContent;
}

void AbsorptionMap::GenerateAbsMap(){
    //    Extract information from radiation map and response function to generate the absorption map fAbsMap.
    fAbsMax = -100;
    fAbsMin = 100;
    Double_t radContent, absContent, radError;
    Long64_t radLinIndex;
    Long64_t absLinIndex;
    Int_t lcoord;
    Int_t meshPerFile = fMeshCount/fNumberOfFiles;
    for (Int_t i=1; i<=fX; i++) {
        for (Int_t j=1; j<=fY; j++) {
            for (Int_t k=1; k<=fZ; k++) {
                for (Int_t m=1; m<=fNumberOfFiles; m++) {
                    for (Int_t n=1; n<=meshPerFile; n++) {
                        lcoord = (m-1)*(meshPerFile)+n;
                        Int_t radCoord[4] = {i,j,k, lcoord};
                        radLinIndex = fRadMap->GetBin(radCoord);
                        radContent = fRadMap->GetBinContent(radLinIndex);
                        radError = fRadMap->GetBinError(radLinIndex);
                        Int_t absCoord[4] = {i,j,k,m};
                        absLinIndex = fAbsMap->GetBin(absCoord);
                        absContent = GetAbsContent(m, radContent);
                        if (n==1) {
                            fAbsMap->SetBinContent(absLinIndex, absContent);
                        } else {
                            fAbsMap->AddBinContent(absLinIndex, absContent);
                            
                        }
                        if (log10(absContent) > fAbsMax) {
                            fAbsMax = log10(absContent);
                        }
                        if (log10(absContent) < fAbsMin && absContent != 0) {
                            fAbsMin = log10(absContent);
                        }
                    }
                }
            }
        }
    }
    fIsAbsMap = true;
    fAbsMapProjection = fAbsMap->Projection(0,1);
}

void AbsorptionMap::AbsExec(THnSparseF *hist, TPad *pad, Int_t fMeshCount, Int_t fNumberOfFiles, Int_t axisMin, Int_t axisMax, TH1F *rfhist){
    //    AbsExec listens to mouse events for interaction with a radiation map and/or the absorption map. Hovering
    //    mouse over a map will generate energy spectra histogram, a left mouse click inside a map will lock the
    //    energy spectra histogram.
    Int_t event = gPad->GetEvent();
    if (event == 11) {
        fAutoUpdate = !fAutoUpdate;
    }
    if (!fAutoUpdate) {
        return;
    }
    const char *padName = gPad->GetName();
    TObject *select = gPad->GetSelected();
    if(!select) return;
    if (!select->InheritsFrom(TH2::Class())) {gPad->SetUniqueID(0); return;}
    TH2 *h = (TH2*)select;
    gPad->GetCanvas()->FeedbackMode(kTRUE);
    
    int px = gPad->GetEventX();
    int py = gPad->GetEventY();
    gPad->SetUniqueID(py);
    Float_t upx = gPad->AbsPixeltoX(px);
    Float_t x = gPad->PadtoX(upx);
    Float_t upy = gPad->AbsPixeltoY(py);
    Float_t y = gPad->PadtoY(upy);
    
    Int_t binx = h->GetXaxis()->FindBin(x);
    Int_t biny = h->GetYaxis()->FindBin(y);
    TObject *obj = gROOT->FindObject("hp");
    if (obj) {
        delete obj; obj = 0;
    }
    
    TH1F *hp = 0;
    if (rfhist == 0) {
        //return; // REMOVE
        
        Float_t bins[fNumberOfFiles];
        for (Int_t i=0; i<=fNumberOfFiles; i++) {
            bins[i] = i;//pow(10,(i+1));
        }
        //Float_t bins[6] = {1, 1e+1, 1e+2, 1e+3, 1e+4, 1e+5};    // Change initializer to NumberOfFiles+1. Change spectras to depend on the input files (cannot be done here as the input files do not really represent certain energy intervals.)
        TObject *obj = gROOT->FindObject("hp");
        if (obj) {
            delete obj; obj = 0;
        }
        hp = new TH1F("hp","", fNumberOfFiles, bins);
    }else{
        hp = (TH1F*)rfhist->Clone("hp");
        hp->Reset();
        const char *hpXTitle = rfhist->GetXaxis()->GetTitle();
        hp->SetXTitle(hpXTitle);
    }
    Double_t content, error;
    Long64_t linIndex;
    if (strcmp(padName, "pad2") == 0) {
        Int_t count = 0;
        for (Int_t i=1; i<=fNumberOfFiles; i++) {
            Int_t meshPerFile = fMeshCount/fNumberOfFiles;
            for (Int_t j=1; j<=meshPerFile; j++) {
                count++;
                Int_t coord[4] = {biny,binx,1,count};
                linIndex = hist->GetBin(coord);
                content = hist->GetBinContent(linIndex);
                error = hist->GetBinError(linIndex);
                if (j==1) {
                    hp->SetBinContent(i, content);
                    hp->SetBinError(i, error);
                } else {
                    hp->AddBinContent(i, content);
                }
            }
        }
        string title = Form("Radiation energy spectra of binX=%d, binY=%d",binx, biny);
        hp->SetName(title.data());
        hp->SetTitle(title.data());
        hp->SetAxisRange(pow(10, axisMin+4), pow(10, axisMax+1) ,"Y");
        hp->SetYTitle("#Phi(E)   (#gamma /cm^{2}/s)");
    } else if (strcmp(padName, "pad4") == 0) {
        for (Int_t i=1; i<=fNumberOfFiles; i++) {
            Int_t coord[4] = {biny,binx,1,i};
            linIndex = hist->GetBin(coord);
            content = hist->GetBinContent(linIndex);
            error = hist->GetBinError(linIndex);
            hp->SetBinContent(i, content);
            hp->SetBinError(i, error);
        }
        string title = Form("Absorption energy spectra of binX=%d, binY=%d",binx, biny);
        hp->SetName(title.data());
        hp->SetTitle(title.data());
        hp->SetAxisRange(pow(10, axisMin+4), pow(10, axisMax) ,"Y");
        hp->SetYTitle("D(E) (Gy/h)");
        //hp->SetYTitle(specYTitle);
    }
    hp->GetXaxis()->SetTitleOffset(1.3);
    hp->GetYaxis()->SetTitleOffset(1.2);
    hp->SetLabelSize(0.07, "X");
    hp->SetLabelSize(0.07, "Y");
    hp->SetNdivisions(505, "X");
    hp->SetNdivisions(505, "Y");
    hp->SetTitleSize(0.06, "X");
    hp->SetTitleSize(0.06, "Y");
    hp->SetFillColor(38);
    pad->cd();
    if (rfhist != 0) {
    pad->SetLogx();
    }
    pad->SetLogy();
    hp->Draw("hist, e");
    pad->Update();
}

void AbsorptionMap::RFExec(TH1F *h, TPad *pad){
    //    RFExec listens to mouse events in the TPad where the response function is originally drawn. A left
    //    click inside the TPad will re-draw the response function.
    Int_t event = gPad->GetEvent();
    if (event == 11) {
        fAutoUpdate = false;
        pad->cd();
        h->Draw("hist");
        pad->Update();
    }
    return;
}

void AbsorptionMap::LogoExec(TImage *img, TPad *pad){
    //    LogoExec listens to mouse events in the TPad where the STRAM logo is originally drawn. A left
    //    click inside the TPad will re-draw the logo.
    Int_t event = gPad->GetEvent();
    if (event == 11) {
        fAutoUpdate = false;
        pad->Clear();
        img->Draw();
        pad->Update();
    }
    return;
}

void AbsorptionMap::Draw(Option_t *option){
    //    Draw interactive maps.
    TVirtualPad *pad = gPad;
    
    if (pad == 0) {
        cerr << "Error in <AbsorptionMap::AbsorptionMap>: You must create a TCanvas before creating an AbsorptionMap" << endl;
        return;
    }else{
        gStyle->SetTitleFontSize(0.08);
    }
    string projName("_Projection_0_1");
    projName = fRadName + projName;
    const char* objName = projName.c_str();
    TObject *obj = gROOT->FindObject(objName);
    if (obj) {
        delete obj; obj = 0;
    }
    fRadMapProjection->GetXaxis()->SetTitleOffset(1.1);
    fRadMapProjection->GetYaxis()->SetTitleOffset(1.2);
    fRadMapProjection->GetZaxis()->SetTitleOffset(1.0);
    fRadMapProjection->SetContour(0);
    fRadMapProjection->SetFillColor(0);
    fRadMapProjection->SetLabelSize(0.06, "X");
    fRadMapProjection->SetLabelSize(0.06, "Y");
    fRadMapProjection->SetLabelSize(0.07, "Z");
    fRadMapProjection->SetNdivisions(505, "X");
    fRadMapProjection->SetNdivisions(505, "Y");
    fRadMapProjection->SetTitleSize(0.06, "X");
    fRadMapProjection->SetTitleSize(0.06, "Y");
    fRadMapProjection->SetTitleSize(0.07, "Z");
    
    if (!fIsAbsMap) {
        cerr << "Warning: No response function defined for <AbsorptionMap::AbsorptionMap> '" << fName << "'. Absorption map will not be generated in TCanvas '" << gPad->GetName() << "'" << endl;
        
        TPad *pad1 = new TPad("pad1","Radiation SurfRF",0,0,0.5,1,0);
        TPad *pad2 = new TPad("pad2","Radiation Contour",0.5,0,1,1,0);
        
        pad1->Draw();
        pad2->Draw();
        
        pad1->cd();
        TImage *logo = TImage::Open("stram_logo.jpg");
        pad1->SetLeftMargin(0.2);
        pad1->SetRightMargin(0.2);
        pad1->SetBottomMargin(0.2);
        logo->Draw();
        pad1->AddExec("logo", Form("AbsorptionMap::LogoExec((TImage*)0x%lx, (TPad*)0x%lx)", (unsigned long)logo, (unsigned long)pad1));

        
        pad2->cd();
        pad2->SetLeftMargin(0.2);
        pad2->SetRightMargin(0.2);
        pad2->SetBottomMargin(0.2);
        pad2->SetLogz();
        fRadMapProjection->Draw("cont1z");
        pad2->AddExec("radExec", Form("AbsorptionMap::AbsExec((THnSparseF*)0x%lx, (TPad*)0x%lx, %i, %i, %i, %i, (TH1F*)0x%lx)", (unsigned long)fRadMap, (unsigned long)pad1, fMeshCount, fNumberOfFiles, fRadMin, fRadMax, (unsigned long)fRF));
        
        gStyle->SetOptStat(0);
        pad1->Modified();
        pad2->Modified();
        
        pad->Update();
        
    }else{
        fAbsMapProjection->GetXaxis()->SetTitleOffset(1.1);
        fAbsMapProjection->GetYaxis()->SetTitleOffset(1.2);
        fAbsMapProjection->GetZaxis()->SetTitleOffset(1.1);
        fAbsMapProjection->SetContour(0);
        fAbsMapProjection->SetFillColor(0);
        fAbsMapProjection->SetLabelSize(0.06, "X");
        fAbsMapProjection->SetLabelSize(0.06, "Y");
        fAbsMapProjection->SetLabelSize(0.07, "Z");
        fAbsMapProjection->SetNdivisions(505, "X");
        fAbsMapProjection->SetNdivisions(505, "Y");
        fAbsMapProjection->SetTitleSize(0.06, "X");
        fAbsMapProjection->SetTitleSize(0.06, "Y");
        fAbsMapProjection->SetTitleSize(0.07, "Z");
        
        TPad *pad1 = new TPad("pad1","Radiation Surf",0,0.5,0.5,1,0);
        TPad *pad2 = new TPad("pad2","Radiation Contour",0.5,0.5,1,1,0);
        TPad *pad3 = new TPad("pad3","Response Function",0,0.01,0.5,0.5,0);
        TPad *pad4 = new TPad("pad4","Absorbed Dose Map",0.5,0,1,0.5,0);
        
        pad1->Draw();
        pad2->Draw();
        pad3->Draw();
        pad4->Draw();
        
        pad1->cd();
        TImage *logo = TImage::Open("stram_logo.jpg");
        pad1->SetLeftMargin(0.15);
        pad1->SetBottomMargin(0.15);
        logo->Draw();
        gStyle->SetOptStat(0);
        pad1->AddExec("logo", Form("AbsorptionMap::LogoExec((TImage*)0x%lx, (TPad*)0x%lx)", (unsigned long)logo, (unsigned long)pad1));
        
        pad2->cd();
        pad2->SetLogz();
        fRadMapProjection->Draw("cont1z");
        pad2->SetLeftMargin(0.15);
        pad2->SetRightMargin(0.2);
        pad2->SetBottomMargin(0.15);
        pad2->AddExec("radExec", Form("AbsorptionMap::AbsExec((THnSparseF*)0x%lx, (TPad*)0x%lx, %i, %i, %i, %i, (TH1F*)0x%lx)", (unsigned long)fRadMap, (unsigned long)pad1, fMeshCount, fNumberOfFiles, fRadMin, fRadMax, (unsigned long)fRF));
        
        pad3->cd();
        fRF->GetXaxis()->SetTitleOffset(1.3);
        fRF->GetYaxis()->SetTitleOffset(1);
        fRF->SetLabelSize(0.07, "X");
        fRF->SetLabelSize(0.07, "Y");
        fRF->SetTitleSize(0.06, "X");
        fRF->SetTitleSize(0.07, "Y");
        pad3->SetLogx();
        pad3->SetLogy();
        pad3->SetLeftMargin(0.15);
        pad3->SetBottomMargin(0.15);
        pad3->AddExec("ResponseFunction", Form("AbsorptionMap::RFExec((TH1F*)0x%lx, (TPad*)0x%lx)", (unsigned long)fRF, (unsigned long)pad3));
        
        //fRF->Draw("hist,e");
        fRF->Draw("hist");
        
        pad4->cd();
        pad4->SetLeftMargin(0.15);
        pad4->SetRightMargin(0.2);
        pad4->SetBottomMargin(0.15);
        pad4->SetLogz();
        fAbsMapProjection->Draw("cont1z");
        pad4->AddExec("absExec", Form("AbsorptionMap::AbsExec((THnSparseF*)0x%lx, (TPad*)0x%lx, %i, %i, %i, %i, (TH1F*)0x%lx)", (unsigned long)fAbsMap, (unsigned long)pad3, fMeshCount, fNumberOfFiles, fAbsMin, fAbsMax, (unsigned long)fRF));
        gStyle->SetOptStat(0);
        
        pad1->Modified();
        pad2->Modified();
        pad3->Modified();
        pad4->Modified();
    }
    
    pad->GetCanvas()->ToggleEventStatus();
    pad->GetCanvas()->Update();
}

void AbsorptionMap::SetRadMapXTitle(const char* title){
    //    Set radiation map Xaxis title.
    fRadMapProjection->SetXTitle(title);
}

void AbsorptionMap::SetRadMapYTitle(const char* title){
    //    Set radiation map Yaxis title.
    fRadMapProjection->SetYTitle(title);
}

void AbsorptionMap::SetRadMapZTitle(const char* title){
    //    Set radiation map Zaxis title.
    fRadMapProjection->SetZTitle(title);
}

void AbsorptionMap::SetRadMapTitle(const char* title){
    //    Set radiation map title.
    fRadMapProjection->SetTitle(title);
}

void AbsorptionMap::SetAbsMapXTitle(const char* title){
    //    Set absorption map Xaxis title.
    if (!fIsAbsMap) {
        cerr << "Error: No response function defined for <AbsorptionMap::AbsorptionMap> '" << fName << "'. Absorption map X-title cannot be set." << endl;
    }else{
        fAbsMapProjection->SetXTitle(title);
    }
}

void AbsorptionMap::SetAbsMapYTitle(const char* title){
    //    Set absorption map Yaxis title.
    if (!fIsAbsMap) {
        cerr << "Error: No response function defined for <AbsorptionMap::AbsorptionMap> '" << fName << "'. Absorption map Y-title cannot be set." << endl;
    }else{
        fAbsMapProjection->SetYTitle(title);
    }
}

void AbsorptionMap::SetAbsMapZTitle(const char* title){
    //    Set absorption map Zaxis title.
    if (!fIsAbsMap) {
        cerr << "Error: No response function defined for <AbsorptionMap::AbsorptionMap> '" << fName << "'. Absorption map Z-title cannot be set." << endl;
    }else{
        fAbsMapProjection->SetZTitle(title);
    }
}

void AbsorptionMap::SetAbsMapTitle(const char* title){
    //    Set absorption map title.
    if (!fIsAbsMap) {
        cerr << "Error: No response function defined for <AbsorptionMap::AbsorptionMap> '" << fName << "'. Absorption map title cannot be set." << endl;
    }else{
        fAbsMapProjection->SetTitle(title);
    }
}

void AbsorptionMap::SetRFXTitle(const char* title){
    //    Set response function Xaxis title.
    if (!fIsAbsMap) {
        cerr << "Error: No response function defined for <AbsorptionMap::AbsorptionMap> '" << fName << "'. Response function X-title cannot be set." << endl;
    }else{
        fRF->SetXTitle(title);
    }
}

void AbsorptionMap::SetRFYTitle(const char* title){
    //    Set response function Yaxis title.
    if (!fIsAbsMap) {
        cerr << "Error: No response function defined for <AbsorptionMap::AbsorptionMap> '" << fName << "'. Response function Y-title cannot be set." << endl;
    }else{
        fRF->SetYTitle(title);
    }
}

void AbsorptionMap::SetRFTitle(const char* title){
    //    Set response function title.
    if (!fIsAbsMap) {
        cerr << "Error: No response function defined for <AbsorptionMap::AbsorptionMap> '" << fName << "'. Response function title cannot be set." << endl;
    }else{
        fRF->SetTitle(title);
    }
}

void AbsorptionMap::SetAbsMapPaletteRange(Double_t ufirst, Double_t ulast){
    //    Set palette axis range.
    if (!fIsAbsMap) {
        cerr << "Error: No response function defined for <AbsorptionMap::AbsorptionMap> '" << fName << "'. Response function title cannot be set." << endl;
    }else{
        fAbsMapProjection->GetZaxis()->SetRangeUser(ufirst, ulast);
    }
}